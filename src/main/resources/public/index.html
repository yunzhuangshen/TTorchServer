<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>TTorch</title>

    <style type="text/css">

        .btnShine {
            -webkit-transition: .6s;
            transition: .6s;
            overflow: hidden;
        }
        .btnShine:focus {
            outline: 0;
        }
        .btnShine:before {
            content: '';
            background: rgba(255, 255, 255, 0.5);
            opacity: .5;
            -webkit-filter: blur(30px);
            filter: blur(30px);
        }
        .btnShine:after {
            content: '';
            background: rgba(255, 255, 255, 0.2);
            opacity: 0;
            -webkit-filter: blur(5px);
            filter: blur(5px);
        }
        .btnShine.shine, .btnShine:hover {
            background: rgb(247, 226, 2);
            cursor: pointer;
        }
        .btnShine.shine:before, .btnShine:hover:before {
            opacity: 0.6;
            -webkit-transition: .7s;
            transition: .7s;
        }
        .btnShine.shine:after, .btnShine:hover:after {
            opacity: 1;
            -webkit-transition: .7s;
            transition: .7s;
        }

        hr {
            display: block;
            height: 2px;
            border: 0;
            border-top: 1px solid #ccc;
            margin: 1em 0;
            padding: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .nav {
            margin-top: 6%;
            height: 600px;
            margin-bottom: 3%;
            width: 280px;
            left: 0;
            top: 0;
            z-index: 2;
            overflow-y: auto;
            overflow-x: visible;
            transform: translate(-280px,0);
            background-color: rgba(255,255,255,0.5);
            position: fixed;
        }

        .checkable{

        }

        .retPanel{
            margin-top: 5px;
        }
        .ssm-overlay {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background-color: rgba(0,0,0,0.2);
            display: none;
            z-index: 1;
        }

        /* Hide default counters */
        ol.clusterize-content {
            counter-reset: clusterize-counter;
            list-style: none;
            padding-left: 10px;
        }

        /* Increment counter for every row */
        ol.clusterize-content li{
            margin: 0 0 0.5rem 0;
            counter-increment: clusterize-counter;
            position: relative;
        }

        /* Display counter and customize it's styling whatever you like */
        ol.clusterize-content li:before {
            content: counter(clusterize-counter) "th trajID: " ;
            position: absolute;
            top: 3px;
            left: 5%;
            padding: 0px 7px;
            line-height: 15px;
            font-size: 10px;
            border-radius: 10px;
            background: #9fd3e8;
            border: 1px solid rgba(0, 140, 186, 0.5);
        }

        /* ************************************************* */

        /* max-height - the only parameter in this file that needs to be edited.
         * Change it to suit your needs. The rest is recommended to leave as is.
         */
        .clusterize-scroll{
            overflow: auto;
        }

        /**
         * Avoid vertical margins for extra tags
         * Necessary for correct calculations when rows have nonzero vertical margins
         */
        .clusterize-extra-row{
            margin-top: 0 !important;
            margin-bottom: 0 !important;
        }

        /* By default extra tag .clusterize-keep-parity added to keep parity of rows.
         * Useful when used :nth-child(even/odd)
         */
        .clusterize-extra-row.clusterize-keep-parity{
            display: none;
        }

        /* During initialization clusterize adds tabindex to force the browser to keep focus
         * on the scrolling list, see issue #11
         * Outline removes default browser's borders for focused elements.
         */
        .clusterize-content{
            outline: 0;
        }

        /* Centering message that appears when no data provided
         */
        .clusterize-no-data td{
            text-align: center;
        }

    </style>

    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.2/css/bootstrap.min.css"
          integrity="sha384-Smlep5jCw/wG7hdkwQ/Z5nLIefveQRIY9nfy6xoR1uRYBtpZgI6339F5dgvm/e9B" crossorigin="anonymous">
    <link rel="stylesheet" href="http://api.map.baidu.com/library/DrawingManager/1.4/src/DrawingManager_min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/clusterize.js/0.18.0/clusterize.css"/>
    <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css"
          integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous">
</head>
<body>
<nav class="nav">

        <div style="width: 100%; height: 40%; position: relative">
            <img style=" margin-left:88%; margin-top:3px; max-width: 45px; max-height: 35px" src="img/swipe.png"
                 alt="swipe image"/>
            <button style="width: 100%; margin-top: -64px " type="button"  class="btn btn-success" disabled>
                Similarity Search Config
            </button>

            <div style=" margin-left: 10%; width:80%; margin-top:10px; height: 40%">
                <div class="input-group mb-3">
                    <div class="input-group-prepend">
                        <span class="input-group-text">Number of results(K): </span>
                    </div>
                    <input type="text" placeholder="15" class="form-control"
                           aria-describedby="inputGroup-sizing-sm" id="k">
                </div>

                <div class="input-group" style="width: auto">
                    <div class="input-group-prepend">
                        <span class="input-group-text">Index</span>
                    </div>
                    <select class="indexGroup" id="index" title="none" onchange="indexChange(this.value)">
                        <option value="eii" selected>Edge based </option>
                        <option value="levi">Vertex based</option>
                    </select>
                </div>
                <div class="input-group" id="simWrapper" style="margin-top: 15px; display: none">
                    <div class="input-group-prepend">
                        <span class="input-group-text">Measure</span>
                    </div>
                    <select class="simGroup" id="sim" title="none" onchange="simChange(this.value)">
                        <option value="DTW" selected>DTW</option>
                        <option value="LCSS">LCSS</option>
                        <option value="EDR">EDR</option>
                        <option value="H">Hausdorff</option>
                        <option value="F">Fréchet</option>
                    </select>

                    <div id="epsilonWrapper" class="input-group mb-3" style="margin-top: 15px; display: none">
                        <div class="input-group-prepend">
                            <span class="input-group-text">Epsilon(LCSS, EDR)</span>
                        </div>
                        <input type="text" placeholder="50" class="form-control"
                               aria-describedby="inputGroup-sizing-sm" id="epsilon" style="width: 30px">
                    </div>
                </div>
                <hr>
            </div>
        </div>
    <hr style="margin-top: 5px; display: block">
    <div style="height: 300px; width: 100%">
        <div style="width: 100%; margin-top: 5px; height: 40%">
            <div class="retPanel">
                <button style="margin-top:5px;width: 100%" type="button" class="btn btn-success" disabled>
                    Result Panel <span style="margin-left: 3px" id="retSize" class="badge badge-danger"></span>
                </button>
                <div id="nonRQ" style="width:100%; text-align: center; display: none">
                    <div class="custom-control custom-checkbox">
                        <input type="checkbox" class="custom-control-input" id="showRaw" checked>
                        <label class="custom-control-label" for="showRaw">display raw path</label>
                    </div>
                    <div class="custom-control custom-checkbox">
                        <input type="checkbox" class="custom-control-input" id="showMapped" checked>
                        <label class="custom-control-label" for="showMapped">display mapped path</label>
                    </div>
                    <div class="custom-control custom-checkbox">
                        <input type="checkbox" class="custom-control-input" id="hideRet">
                        <label class="custom-control-label" for="hideRet">hide results</label>
                    </div>
                </div>
            </div>
            <div class="clusterize">
                <div id="scrollArea" class="clusterize-scroll ">
                    <ol id="contentArea" class="clusterize-content"
                        style="width: 90%;text-align:center">
                    </ol>
                </div>
            </div>
            <div class="retPanel">
                <div class="progress">
                    <span class="badge badge-secondary">progress</span>
                    <div id="progressBar" class="progress-bar progress-bar-striped" role="progressbar"
                         style="width: 0%; margin-left: 5px" aria-valuenow="0" aria-valuemin="0"
                         aria-valuemax="100"></div>
                </div>
            </div>
        </div>
    </div>
</nav>
<div style="position:absolute; margin-top: 20px; margin-left: 20px; z-index:3">
    <a href="#" id="btn_nav" class="btn btn-light ssm-toggle-nav"
       style="padding-bottom: 1px; padding-left: 10px; padding-right: 10px">
        <object id="svg1" data="img/gear.svg" type="image/svg+xml" style="padding-right: 3px"></object>
        Settings
    </a>
</div>
<div style="position: relative; z-index:3">

    <div class="btn-group" style=" position:absolute; margin-top: 10px; margin-left: 35%; margin-right: 35%; align-items: baseline"
         role="group"
         aria-label="Basic example">
        <button id="btn0" type="button" style="margin-right: 1px" class="btn btn-primary btnShine" value=0>Similarity Search
        </button>
        <button id="btn1" type="button" style="margin-right: 1px" class="btn btn-secondary" value=1>Range Search
        </button>
        <button id="btn2" type="button" style="margin-right: 1px" class="btn btn-secondary btnShine" value=2>Path Query
        </button>
        <button id="btn3" type="button" style="margin-right: 1px" class="btn btn-secondary btnShine" value=3>Strict Path
            Query
        </button>
    </div>

    <div class="input-group mb-3"
         style="position:absolute; margin-top: 50px; width: 70%; margin-left:15%; margin-right: 15%;">
        <input type="text" id="input" class="form-control" size="25"
               placeholder="draw the window for RangeSearch, or the path for other types of queries"
               aria-label="search" aria-describedby="button-addon4" style="margin-left: 50px" disabled>
        <div class="input-group-append" id="button-addon4">
            <button class="btn btn-outline-danger" id="btnClear" type="button">Clear</button>
            <button class="btn btn-outline-success" id="btnSearch" style="margin-left: 1px" type="button">Search
            </button>
        </div>
    </div>

    <div id="info" class="alert alert-warning" role="alert"
         style="height: 45px;position:absolute; z-index:1; margin-top: 93px; margin-left: 25%; margin-right: 25%; width: 55%; font-size: medium; text-align:center ;display: none">
    </div>
</div>
<div style=" height: 100%; width: 100%" id="map"></div>
<canvas id="canvas"></canvas>
<a href="https://github.com/tgbnhy/torch-trajectory"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>
<!-- JavaScript field -->
<script src="https://code.jquery.com/jquery-3.3.1.js"
        integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60="
        crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.2/js/bootstrap.min.js"
        integrity="sha384-o+RDsa0aLu++PJvFqy8fFScvbHFLtbvScb8AjopnFD+iEQ7wo/CG0xlczd+2O/em"
        crossorigin="anonymous"></script>
<script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&ak=o55gGAr8In322oxznMl5cojFABFo5hjE"></script>
<script type="text/javascript"
        src="http://api.map.baidu.com/library/DrawingManager/1.4/src/DrawingManager_min.js"></script>
<script type="text/javascript"
        src="http://mapv.baidu.com/build/mapv.min.js"></script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/clusterize.js/0.18.0/clusterize.js"></script>
<!-- touchSwipe library -->
<script src="http://labs.rampinteractive.co.uk/touchSwipe/jquery.touchSwipe.min.js"></script>
<!-- Slider Javascript file -->
<script type='text/javascript' src='./js/jquery.slideandswipe.js'></script>
<!-- my script -->
<script type="text/javascript" src="./js/data.js"></script>

<script>

    //helper functions that do not depend on other modules.

    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function calc_cluster(progress) {
        return Math.floor(progress/100);
    }

    function calc_progress(overall_percentage){
        return Math.floor(overall_percentage * ids.length / 100)
    }

    function calc_percentage(p){
        return p + 6/ids.length * 100;
    }

    function toListData(ids) {
        let data = [];
        let counter = 0;
        ids.forEach(id => {
            data.push('<li>' +
                '<div style="width: 100%; margin-left: 5px"">' +
                '<button class="btn btn-outline-success btn-xs checkable" style="margin-left: 60px; font-size: x-small" value="'+ counter+'">'+id+'</button>' +
                '</div>' +
                '</li>');
            if (++counter === 100)
                counter = 0;
        });

        return data;
    }

    function indexChange(val){
        if (val === "eii")
            $('#simWrapper').hide();
        else
            $('#simWrapper').show();
    }

    function simChange(val){
        if (val === "LCSS" || val === "EDR")
            $('#epsilonWrapper').show();
        else
            $('#epsilonWrapper').hide();
    }

    //display news
    function badInfo( content) {
        let element = $('#info');
        element.removeClass("alert-success").addClass("alert-warning")
        element.text(content);
        element.show();
    }

    function goodInfo( content){
        let element = $('#info');
        element.removeClass("alert-warning").addClass("alert-success")
        element.text(content);
        element.show();
    }

    $(document).ready(() => {

        // display and hide similarity panel when the index settings changes
        function clear1() {
            curClusterId = 0;
            ids = [];
            map_data = [];
            slot = [];
            clusterize.clear();
            $(".retPanel").hide();
            map.clearOverlays();
            if (curBtnState === 1){
                map.addOverlay(rectangle);
            }

            let infoElement = $('#info');
            infoElement.text("");
            infoElement.hide();
            first = true;
            lineLayer = undefined;
            animationLayer = undefined;
            singleLineLayer = undefined;
            singleAnimationLayer = undefined;

            hide = false;
        }

        function downloadFullTraj(curCluster, firstTime) {

            if (slot[curCluster]) return;
            console.log("download trajectory for cluster: "+curCluster);
            slot[curCluster] = true;
            let table_max_idx = ids.length - 1;
            let begin_idx = curCluster * 100;
            let end_idx = (curCluster+1) * 100 - 1;
            console.log("begin_idx: "+begin_idx);
            if (begin_idx >= table_max_idx) return;
            if (table_max_idx < end_idx)
                end_idx = table_max_idx;

            let url = URL_PREFIX + TRAJ_ID_API;

            let arr = [];
            //todo get ids and request for full trajectory.
            for (let i = begin_idx; i <= end_idx; i++) {
                arr.push(ids[i]);
            }

            $.ajax({
                url: url,
                data: {idSet : JSON.stringify(arr)},
                dataType:'json',
                cache: false,
                type: "GET",
                success: function(res) {
                    map_data[curCluster] = res;
                    console.log("find map_data for cluster: "+ curCluster);
                    if (firstTime) {
                        display();
                        displayed = curCluster;
                    }
                },

                error: function(xhr) {
                    console.log("cannot download cluster: "+clusterize+" . Server unavailable");
                }
            });
        }

        function displayOnInit(trajs){
            //random select 100 trajectories
            let rand = getRandomInt(0, 1);
            let begin = rand * 100;
            let end = (rand + 2) * 100;
            trajs = trajs.slice(begin, end);


            let times = [];
            for (let k = 0; k < 100; k++){
                let traj = trajs[k];
                let coordsArr = traj.geometry.coordinates;
                let i;
                let random1 = getRandomInt(0,20);
                let random2 = 10;
                if (k<50) {
                    for (i = 0; i < coordsArr.length; i++) {
                        times.push({
                            geometry: {
                                type: 'Point',
                                coordinates: [coordsArr[i][0], coordsArr[i][1]]
                            },
                            count: 1,
                            time: i+random1
                        })
                    }
                }else {
                    let m = random2;
                    for (i = coordsArr.length - 1; i >= 0; i--) {
                        times.push({
                            geometry: {
                                type: 'Point',
                                coordinates: [coordsArr[i][0], coordsArr[i][1]]
                            },
                            count: 1,
                            time: m++
                        })
                    }
                }
            }

            if (!lineLayer) {
                trajData = new mapv.DataSet(trajs);
                timeData = new mapv.DataSet(times);
                lineLayer = new mapv.baiduMapLayer(map, trajData, mapv_option_line_light_purple);
                animationLayer = new mapv.baiduMapLayer(map, timeData, mapv_option_dot_animation);
            }else{
                trajData.set(trajs);
                timeData.set(times);
            }

            //timeData.set(); // 修改数据
            // lineLayer.show(); // 显示图层
            // animationLayer.show();
            // mapvLayer.hide(); // 删除图层
        }

        function display() {
            let trajs = map_data[curClusterId];
            let times = [];
            console.log(trajs);
            trajs.forEach(traj =>{

                let coordsArr = traj.geometry.coordinates;
                let i;
                for( i = 0; i < coordsArr.length; i ++){
                    times.push({
                        geometry: {
                            type: 'Point',
                            coordinates: [coordsArr[i][0], coordsArr[i][1]]
                        },
                        count:1,
                        time: i
                    })
                }
            });

            if (!lineLayer) {
                trajData = new mapv.DataSet(trajs);
                timeData = new mapv.DataSet(times);
                lineLayer = new mapv.baiduMapLayer(map, trajData, mapv_option_line_light_purple);
                animationLayer = new mapv.baiduMapLayer(map, timeData, mapv_option_dot_animation_init);
            }else{
                trajData.set(trajs);
                timeData.set(times);
            }

        }

        function displaySingle(index) {

            // mapV API
            // draw retrieved trajecory map_data on map
            console.log("display map data on cluster: "+curClusterId);
            console.log("index: "+ index);
            let trajs;

            trajs = map_data[curClusterId];
            let temp = [];
            temp.push(trajs[index]);
            trajs = temp;
            let times = [];

            let coordsArr = trajs[0].geometry.coordinates;
            let i;
            for (i = 0; i < coordsArr.length; i++) {
                times.push({
                    geometry: {
                        type: 'Point',
                        coordinates: [coordsArr[i][0], coordsArr[i][1]]
                    },
                    count: 1,
                    time: i
                })
            }

            if (!singleLineLayer) {

                singleTrajData = new mapv.DataSet(trajs);
                singleTimeData = new mapv.DataSet(times);
                singleLineLayer = new mapv.baiduMapLayer(map, singleTrajData, mapv_option_line_single);
                singleAnimationLayer = new mapv.baiduMapLayer(map, singleTimeData, mapv_option_single_line_dot_animation);
            }else{
                singleTrajData.set(trajs);
                singleTimeData.set(times);
            }

            hide = true;
            lineLayer.hide();
            animationLayer.hide();
            singleLineLayer.show();
            singleAnimationLayer.show();
            //rawLayer.show();
            //mappedLayer.show();
        }

        function makeRaw(coorArray) {

            let geo = [];
            coorArray.forEach(coor=>{
               geo.push([coor.lng, coor.lat])
            });

            //gen mapVformat
            let trajs =  [{
                geometry: {
                    type: "LineString",
                    coordinates:geo
                },}];

            if (!rawLayer) {
                rawData = new mapv.DataSet(trajs);
                rawLayer = new mapv.baiduMapLayer(map, rawData, mapv_option_line_raw);
            }else{
                rawData.set(trajs);
            }
            rawLayer.hide();
        }

        function makeMapped(coorArray) {

            let geo = [];
            coorArray.forEach(coor=>{
                geo.push([coor.lng, coor.lat])
            });

            //gen mapVformat
            let trajs =  [{
                geometry: {
                    type: "LineString",
                    coordinates:geo
                },}];

            if (!mappedLayer) {
                console.log(trajs);
                mappedData = new mapv.DataSet(trajs);
                mappedLayer = new mapv.baiduMapLayer(map, mappedData, mapv_option_line_matched);
            }else{
                mappedData.set(trajs);
            }
            mappedLayer.hide();
        }

        let displayed;
        let clusterize = new Clusterize({
            scrollId: 'scrollArea',
            contentId: 'contentArea',
            rows_in_block:100,          // displayOnInit 100 records each time
            blocks_in_cluster:2,
            callbacks:{
                scrollingProgress:(percentage)=>{

                    // 1. displayOnInit progress bar
                    let percentageForPBar = calc_percentage(percentage);
                    let progress = calc_progress(percentage);
                    curClusterId = calc_cluster(progress);

                    console.log("percentage: "+percentage);
                    // console.log("percentage: "+percentage);
                    // console.log("percentage for p bar: "+percentageForPBar)
                    $('#progressBar').css('width', percentageForPBar+'%')
                        .attr('aria-valuenow', percentageForPBar)
                        .text(percentageForPBar.toFixed(2)+"%");

                    // no need to require trajectories if the stuff has been cached on client side
                    if (!slot[curClusterId])
                        downloadFullTraj(curClusterId, false);

                    if (displayed !== curClusterId){
                        if (map_data[curClusterId]) {
                            display();
                            displayed = curClusterId;
                        }
                    }

                    if ( !slot[curClusterId + 1]) {
                        if (maxClusterId !== curClusterId) {
                            downloadFullTraj(curClusterId + 1, false);
                        }
                    }

                    if(hide){
                        lineLayer.show();
                        animationLayer.show();
                        if (singleLineLayer) {
                            singleLineLayer.hide();
                            singleAnimationLayer.hide();
                        }
                        hide = false;
                        $('#hideRet').prop('checked', false); // Unchecks it
                    }
                },

                clusterChanged: ()=>{
                    if (firstTime){
                        firstTime = false;
                        return;
                    }

                    let progress = calc_progress(clusterize.getScrollProgress());
                    if (progress ===0 ) return;

                    let curCluster = calc_cluster(progress);
                    curClusterId = curCluster;
                    console.log("cluster changed. cur cluster id: "+curClusterId);

                    if(map_data[curClusterId]) {
                        display();
                        displayed = curClusterId;
                    }

                    $('.checkable').click((e)=>{
                        let index = parseInt($(e.target).attr("value"));
                        console.log("clicked: ");
                        $('#hideRet').prop('checked', false); // Unchecks it
                        displaySingle(index);
                    });
                },
            }
        });

        $('.nav').slideAndSwipe();
        $('.retPanel').hide();
        $("#btn_nav").click();
        console.log(URL_PREFIX+INIT_FILE);
        $.ajax({
            url: URL_PREFIX+INIT_FILE,
            dataType:'json',
            cache: false,
            type: "GET",
            success: function(res) {
                displayOnInit(res);
            },

            error: function(xhr) {
                console.log("error message: ");
                console.log(xhr);
            }
        });

        for (let i = 0; i <= 3; i++) {
            let curBtn = $('#btn' + i);
            curBtn.click(() => {

                let input = $('#input');
                if (i === SIMILARITY_SEARCH)
                    input.attr("placeholder", "draw a path for current query type");
                else if(i === RANGE_SEARCH)
                    input.attr("placeholder", "draw a window for current query type");
                else
                    input.attr("placeholder", "draw a path or input a street name for current query type");
                input.val("");

                if (curBtnState !== i) {
                    $('#btn'+curBtnState).removeClass("btn-primary").addClass("btn-secondary");
                    curBtn.removeClass("btn-secondary").addClass("btn-primary");
                    curBtnState = parseInt(curBtn.val());
                    if (curBtnState === SIMILARITY_SEARCH || curBtnState === RANGE_SEARCH){
                        $('#input').prop('disabled',true)
                    } else {
                        $('#input').prop('disabled',false)

                    }
                    console.log(curBtn.val())
                }

                $('#info').hide();
            });
        }

        $('#btn0').click();

        // baidu API
        let map = new BMap.Map("map");    // 创建Map实例
        map.centerAndZoom(new BMap.Point(-8.594061, 41.162726), 13);  // 初始化地图,设置中心点坐标和地图级别
        map.enableScrollWheelZoom(true); // 开启鼠标滚轮缩放
        let bottom_right_navigation = new BMap.NavigationControl({
            anchor: BMAP_ANCHOR_BOTTOM_RIGHT,
            offset: new BMap.Size(10, 90)
        });
        map.addControl(bottom_right_navigation);
        // map.setMapStyle({style: 'light'});
        map.setMapStyle({styleJson:mapStyle});

        let drawer = new BMapLib.DrawingManager(map, {
            isOpen: false,                          // disable drawing mode
            enableDrawingTool: true,                // displayOnInit tool bar
            drawingToolOptions: {
                anchor: BMAP_ANCHOR_BOTTOM_RIGHT,      // position of the tool bar
                offset: new BMap.Size(60, 40),        // offset from the position
                scale: 0.8,
                drawingModes: [                    // functions on tool bar
                    // BMAP_DRAWING_MARKER,
                    // BMAP_DRAWING_CIRCLE,
                    BMAP_DRAWING_POLYLINE,
                    // BMAP_DRAWING_POLYGON,
                    BMAP_DRAWING_RECTANGLE
                ]
            },
            polylineOptions: pathStyle,
            rectangleOptions: rectStyle
        });

        let lineComplete = function(line){

            if (curBtnState === RANGE_SEARCH) {
                badInfo("System detected the line, you might want to perform a query other than RangeSearch");
                // $('#btn0').click();
                // curBtnState = SIMILARITY_SEARCH;
                let time = 500;
                for (let i = 0; i < 8;i++) {
                    setTimeout(()=>{$('.btnShine').toggleClass("shine")}, time*i);
                }
            }

                let temp = line.getPath();
                let path = "[";
                temp.forEach((item) => {
                    path += "[" + item.lat + "," + item.lng + "],"
                });
                path = path.substr(0, path.length - 1);
                path += "]";
                $("#input").val(path);
        };

        let rectComplete = function (rect) {

            if (curBtnState !== RANGE_SEARCH) {
                $('#btn1').click();
                badInfo("System detected the window and query type is set to RangeQuery.");
                curBtnState = RANGE_SEARCH;
            }

            // 0 -- upper left
            // 1 -- upper right
            // 2 -- lower right
            // 3 -- lower left
            let pStart = new BMap.Point(rect.getPath()[0].lng, rect.getPath()[0].lat);
            let pEnd = new BMap.Point(rect.getPath()[2].lng, rect.getPath()[2].lat);
            rectangle = new BMap.Polygon([
                new BMap.Point(pStart.lng, pStart.lat),
                new BMap.Point(pEnd.lng, pStart.lat),
                new BMap.Point(pEnd.lng, pEnd.lat),
                new BMap.Point(pStart.lng, pEnd.lat)
            ], {strokeColor: 'rgba(255,255,255, 0.01)', strokeWeight: 1, strokeOpacity: 0.1});

            let temp = [
                rect.getPath()[0],
                rect.getPath()[2]
            ];
            let window = "[";
            temp.forEach((item) => {
                window += "[" + item.lat + "," + item.lng + "],"
            });
            window = window.substr(0, window.length - 1);
            window += "]";
            $("#input").val(window);
        };

        drawer.addEventListener("polylinecomplete", lineComplete);

        drawer.addEventListener("rectanglecomplete", rectComplete);


        $('#showRaw').change(function(){
            if($(this).is(':checked')) {
                rawLayer.show();
            } else {
                rawLayer.hide();
            }
        });

        $('#showMapped').change(function(){
            if($(this).is(':checked')) {
                mappedLayer.show();
            } else {
                mappedLayer.hide();
            }
        });

        $('#hideRet').change(function(){
            if($(this).is(':checked')) {
                if (singleLineLayer) {
                    singleLineLayer.hide();
                    singleAnimationLayer.hide();
                }
                lineLayer.hide();
                animationLayer.hide();
                hide = true;
            } else {
                hide = false;
                lineLayer.show();
                animationLayer.show();
            }
        });

        $("#btnClear").click(()=>{
            clear1();
        });

        $("#btnSearch").click(()=>{
            
            let url = URL_PREFIX + apiMap[curBtnState];
            let data;
            console.log(url);
            let inputVal = $("#input").val();
            if (curBtnState === RANGE_SEARCH){
                console.log(inputVal.length);
                if (inputVal.length === 0) {
                    badInfo("A window for the query is required!");
                    return;
                }

                if (inputVal.split("],[").length !== 2) {
                    badInfo("A window is defined by an upper left point and a lower right point");
                    return;
                }
                data = {query: inputVal};
            } else {

                if (inputVal.length === 0) {
                    badInfo("A path for the query is required!");
                    return;
                }

                if (curBtnState === SIMILARITY_SEARCH) {
                    if (inputVal.split("],[").length < 2) {
                        badInfo("A path is defined by two or more points.\n Format: [[lat, lng],[lat, lng],[lat, lng]...]");
                        return;
                    }

                    let k = 15;
                    let input  = $('#k').val();
                    if ( input.length !== 0){
                        let temp = Number(input);
                        if (temp)
                            k = temp;
                    }

                    let epsilon = 50;
                    input = $('#epsilon').val();
                    if (input.length !== 0){
                        let temp = parseInt(input);
                        if (temp)
                            epsilon = temp;
                    }

                    let index = $('.indexGroup option:selected').val();
                    let simFunc = ($('.simGroup option:selected').val());
                    
                    data = {
                        query: inputVal,
                        k: k,
                        index: index,
                        measure: simFunc,
                        epsilon : epsilon
                    };

                }else {
                    if (inputVal.split("],[").length === 1)
                        data = {name:inputVal};
                    else
                        data = {query: inputVal};
                }
            }

            console.log(data);

            goodInfo("The query is under processing, please wait...");

            $.ajax({
                url: url,
                data: data,
                dataType:'json',
                cache: false,
                type: "GET",
                success: function(res) {
                    // clear1();
                    console.log(res);
                    if (!res.formatCorrect) {
                        badInfo("Query is not in the right format. Please do double check!");
                        return;
                    }

                    let retObj = res.retObj;
                    if (!retObj.mappingSucceed){
                        badInfo("Query can not be properly map-matched to road network!")
                        return;
                    }

                    let retSize = parseInt(retObj.retSize);
                    if ( retSize === 0){
                        goodInfo("no trajectory meets the requirement");
                        return;
                    }

                    clear1();
                    
                    if (retSize > 100){
                        goodInfo("There are "+retSize+" of qualified trajectories found, 100 of them are displayed.");
                    } else{
                        goodInfo("There are "+retSize+" of qualified trajectories found.")
                    }

                    ids = retObj.ids;
                    console.log("ids: "+ids);
                    for (let i = 0; i < ids.length; i++)
                        slot[i] = false;

                    if (res.queryType === "RQ"){
                        $("#nonRQ").hide();
                    }else{
                        $("#nonRQ").show();
                        makeRaw(retObj.rawTrajectory);
                        makeMapped(retObj.mappedTrajectory);
                        if ($('#showRaw').is(':checked')) rawLayer.show();
                        if ($('#showMapped').is(':checked')) mappedLayer.show();
                    }

                    if (res.queryType === "TK") {
                        console.log(res.queryType);
                        ids.reverse();
                    }

                    clusterize.append(toListData(ids));

                    downloadFullTraj(curClusterId, true);
                    maxClusterId = calc_cluster(ids.length - 1);
                    $("#retSize").text(ids.length);
                    $(".retPanel").show();

                    $('.checkable').click((e)=>{
                        let index = parseInt($(e.target).attr("value"));
                        $('#hideRet').prop('checked', false); // Unchecks it
                        displaySingle(index);
                    });
                },
                error: function(xhr) {
                    badInfo("server unavailable");
                }
            });
        });

    });
</script>
</body>
</html>
